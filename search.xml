<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Happy New Year]]></title>
      <url>%2F2016%2F12%2F31%2Fhappy-new-year%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo在github上构建免费的Web应用]]></title>
      <url>%2F2016%2F12%2F31%2Fblog-hexo-github%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartSoftware Nodejs GitHub Git Install Hexo1npm install -g hexo Create New Project12345678910111213hexo init nodejs-hexo[info] Creating file: source/_posts/hello-world.md[info] Creating file: package.json[info] Creating file: .gitignore[info] Copying file: _config.yml[info] Copying file: scaffolds/draft.md[info] Copying file: scaffolds/page.md[info] Copying file: scaffolds/photo.md[info] Copying file: scaffolds/post.md[info] Creating folder: source/_drafts[info] Creating folder: scripts[info] Copying theme data...[info] Initialization has been done. Start blogging with Hexo! Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jekyll Local Testing In XP]]></title>
      <url>%2F2016%2F12%2F25%2FJekyll-Local-Testing%2F</url>
      <content type="text"><![CDATA[1. Software Ruby: rubyinstaller-1.9.3-p125 DevKit: DevKit-tdm-32-4.5.1-20101214-1400-sfx Jekyll Version(1.1.2) 2.Install Ruby: Add PATH DevKit: cd DevKit ruby dk.rb init ruby dk.rb install Jekyll： gem install jekyll -v &quot;1.1.2&quot; jekyll -v display version 1.1.2 Issue Liquid error: incompatible character encodings: UTF-8 and GBK Fix:File: jekyll-1.1.2\lib\jekyll\convertible.rb change self.content = File.read(File.join(base, name)) as self.content = File.read(File.join(base, name),:encoding=&gt;”utf-8”) Testing jekyll new blog cd blog jekyll build jekyll server view website:http://localhost:4000/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[圣诞快乐]]></title>
      <url>%2F2016%2F12%2F24%2FMerry-Christmas%2F</url>
      <content type="text"><![CDATA[Merry Christmas 圣诞快乐]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何有效使用 GitHub]]></title>
      <url>%2F2016%2F04%2F07%2Fhow-to-use-github-effective%2F</url>
      <content type="text"><![CDATA[这是一个知乎问题下我的回答，原帖传送门。 前言GitHub 是很多「modern」程序员使用频度很高的网站，但各人从中汲取的养分不同。有的人借助它的力量扬名立万成为一代大神；有的人迷失其中，天天在其中流连却成长有限。 而我，成长为了一名主要用 GitHub 写博客的少年，Sad story！ :joy::joy::joy: 这当然不是我想要的，要知道我也是一个有大神梦的人啊。:clap: 下面给出我对自己的分析和总结，希望在以后继续使用 GitHub 的过程中能持续总结重构，形成自己高效使用它的方式。 分析我目前使用 GitHub 的频度很高，收获一般，从使用习惯上来分析： 好习惯 将 GitHub Pages 作为写博客的工具，能使用 Markdown 专注于内容。 Follow 了一些 Android 领域的牛人，经常关注他们关注的东西。 坏习惯 刷 Dashboard 太频繁，浪费时间。 了解别人的项目不深入，往往只停留在看看「是什么」的阶段，没有了解「怎么实现」，更不用说「这里值得学习」。 没有长期维护的项目，动手写代码太少。 总结我认为的有效使用 GitHub 的方式： Follow 你感兴趣的领域厉害的人物，持续关注他们在 GitHub 上的活动，选择其中优秀的资源学习之。 tip: 学习要深入，不要止步于泛泛地了解。 将你自己的玩具项目源码大胆发上去，不断用你学习到的优秀的模式和架构对它们进行重构，形成你个人比较固定的编程规范。 tip: 拥有自己长期维护的项目，多重构。 学习并逐渐掌握 GitHub 的工作流，使用版本控制和 Issues、Milestones 等记录和掌控自己业余项目的进度。 善用搜索，善用 awesome 系项目。 勤做笔记，使用仓库/gh-pages/Issues 写博客都是不错的方式。 参与到别人的项目中去，使用别人项目的过程中遇到问题先去 Issues 和 Pull Requests 里寻找解决方案，找不到的尝试自己去修复提 Pull Request，能力所限修复不了的提 Issues 寻求帮助。 tip: 提 Issues 和 Pull Request 先阅读一下项目里的 CONTRIBUTING，遵循项目的规范。 如果可以，发动你身边的朋友们跟你一起用起来，有适当的好友互动会更有趣。 tip: 不要把它玩成了纯社交，不停刷 timeline 那就不如玩朋友圈了。@mzlogin，欢迎互动。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为 Markdown 生成 TOC 的 Vim 插件]]></title>
      <url>%2F2015%2F12%2F19%2Fvim-markdown-toc%2F</url>
      <content type="text"><![CDATA[因为饱受 GFM 和 Redcarpet 两种 Markdown 引擎生成 TOC 链接的差异的折磨，而我又不得不同时使用它们——博客基于 Jekyll 使用 Redcarpet（Update 2016/09/16: GitHub Pages 现在已经改为只支持 kramdown），而其它放在 GitHub 仓库里的文档使用 GFM，我决定为我常用的 Markdown 编辑器 Vim 做一款同时支持 GFM 和 Redcarpet 两种 TOC 链接风格的 Table of Contents 自动生成插件。 这算是我真正意义上完全独立开发的第一款实用 Vim 插件，当然开发过程中也参考了别人的做法。 下载地址 vim-markdown-toc 功能 为 Markdown 文件生成 Table of Contents，目前支持 GFM 和 Redcarpet 两种链接风格。 更新已经存在的 Table of Contents。 保存文件时自动更新 Table of Contents。 使用方法生成 Table of Contents将光标移动到想在后面插入 Table of Contents 的那一行，然后运行下面的某个命令： :GenTocGFM 生成 GFM 链接风格的 Table of Contents。 适用于 GitHub 仓库里的 Markdown 文件，比如 README.md，也适用用于生成 GitBook 的 Markdown 文件。 :GenTocRedcarpet 生成 Redcarpet 链接风格的 Table of Contents。 适用于使用 Redcarpet 作为 Markdown 引擎的 Jekyll 项目或其它地方。 更新已存在的 Table of Contents通常不需要手动做这件事，保存文件时会自动更新已经存在的 Table of Contents。 除非是在配置里关闭了保存时自动更新，并且维持插入 Table of Contents 前后的 &lt;!-- vim-markdown-toc --&gt;，此时可使用 :UpdateToc 命令手动更新。 安装方法推荐使用 Vundle 来管理你的 Vim 插件，这样你就可以简单三步完成安装： 在你的 vimrc 文件中添加如下内容： 1Plugin 'mzlogin/vim-markdown-toc' :so $MYVIMRC :PluginInstall 使用 vim-plug 安装的过程的与此基本一样。 配置选项 g:vmt_auto_update_on_save 默认值：1 插件会自动更新已经存在的 Table of Contents，如果你不想要这个功能，可以在你的 vimrc 文件里加入如下内容关闭： 1let g:vmt_auto_update_on_save = 0 g:vmt_dont_insert_fence 默认值：0 在默认情况下，:GenTocXXX 命令会在插入的 Table of Contents 前后加上 &lt;!-- vim-markdown-toc --&gt;，这是为了实现自动和手动更新 Table of Contents 功能。 如果你不想看到它们，可以在 vimrc 文件里加入如下内容移除： 1let g:vmt_dont_insert_fence = 1 需要注意的是移除之后插件将无法再帮你保存文件时自动更新 Table of Contents 了，也无法使用 :UpdateToc 命令了。这里如果还想更新 Table of Contents，只能先手动删除已经存在的，然后重新运行 :GenTocXXX 命令。 屏幕截图使用本插件生成 TOC 的英文文档在线示例 使用本插件生成 TOC 的中文文档在线示例 参考链接 GFM 与 Redcarpet 的不同点 ajorgensen/vim-markdown-toc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为 Vim 添加 Smali 语法高亮和 Taglist 支持]]></title>
      <url>%2F2015%2F06%2F23%2Fvim-taglist-smali%2F</url>
      <content type="text"><![CDATA[Smali 相当于 Dalvik 虚拟机的汇编语言，语法可以参考 Dalvik opcodes。 本文介绍的是如何使用 Vim + Ctags + Taglist（或 Tagbar） 来实现如下需求： 目录 TOC{:toc} 最终效果图： 当然因为现在 Android 应用打包时都会做不同程度的混淆，最后配置完后在 Taglist 下看到的可能是一堆 a，b，c 之类的名字。:-P 我的最终配置托管在 GitHub 上可供参考：https://github.com/mzlogin/config-files。 以下内容假设读者已经配置好 Vim + Ctags + Taglist（或 Tagbar） 环境，掌握了安装 Vim 插件的方法。 Smali 语法高亮方法： 安装 Vim 插件 https://github.com/mzlogin/vim-smali。 如果你也跟我一样使用方便的 Vundle 管理插件，那你只需要在你的 _vimrc 文件里添加 Plugin &#39;mzlogin/vim-smali&#39;，然后 so % 重新加载配置文件，再 :PluginInstall 即安装完成。 如果是手动安装插件，那么可以点击插件链接页面右下角的「Download ZIP」按钮下载插件文件然后安装。 跳转到定义方法： 为 Ctags 添加 Smali 语言支持。 新建文件 ~/.ctags 并将如下内容复制进去： 1234--langdef=smali--langmap=smali:.smali--regex-smali=/^\.field (public |private |protected )?(static )?(final )?(synthetic )?([^:]*):.*/\5/f,field/--regex-smali=/^\.method (public |private |protected )?(static )?(final )?(varargs )?(bridge )?(synthetic )?(declared-synchronized )?(.*)\(.*/\8/m,method/ 打开 Smali 文件后使用 :!ctags -R . 生成 tags 文件，对解析到的变量和方法等就可以 Ctrl-] 跳转到定义了。 注：~ 是指用户目录，Linux 和 Mac OS X 用户应该都明白，Windows 用户可以在 Vim 下 :ec $HOME 查看该目录所在，比如 Win7 下是 C:\Users\用户名。 Windows 下无法直接新建以 「.」 开头的文件名，可以先新建一个 txt 文件，然后在命令行下 rename file.txt .ctags。 Taglist/Tagbar 支持Taglist 和 Tagbar 是两个同类插件，任选其一即可，我以前使用 Taglist，最近切换到 Tagbar。 使用 Taglist方法： 为 Taglist 添加 Smali 语言支持。 在 _vimrc 文件里添加一行即可： 1let g:tlist_smali_settings = "smali;f:field;m:method" 使用 Tagbar方法： 为 Tagbar 添加 Smali 语言支持。 在 _vimrc 文件里添加如下内容即可： 1234567let g:tagbar_type_smali = &#123; \ 'ctagstype' : 'smali', \ 'kinds' : [ \ 'f:field', \ 'm:method', \ ]\ &#125; 到此，我们要实现的三个目标就已经完成了。 后话对于实现 Taglist 支持这一步，我在网上搜索良久未找到有效解决方案，最后是打开 taglist.vim 文件，看到有如下代码段后才知道能这么做的，所以以后遇到问题找不到方法而有源码的时候，读它吧！ 切换到 Tagbar 之后的解决方案与此类似。 123456789101112131415161718192021222324" ..." php languagelet s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'" python languagelet s:tlist_def_python_settings = 'python;c:class;m:member;f:function'" ... " Skip files which are not supported by exuberant ctags " First check whether default settings for this filetype are available. " If it is not available, then check whether user specified settings are " available. If both are not available, then don't list the tags for this " filetype let var = 's:tlist_def_' . a:ftype . '_settings' if !exists(var) let var = 'g:tlist_' . a:ftype . '_settings' if !exists(var) return 1 endif endif" ... 当前解决方案 Ctags 只解析、Taglist/Tagbar 只显示了 field 和 method 两类 tag，我对此的原理不是很懂，但是猜想应该是上面 .ctags 文件里的 --regex-smali 里我们只告诉了 Ctags 如何解析这两种 tag，本来考虑后续有时间把 class 等更多内容做进来，但转念一想，一个 smali 文件里也就一个类，这种需求似乎不那么强烈，遂作罢。 参考链接 让Vim和Ctags支持smali语法 让tagbar支持markdown]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows 实现单实例进程的两种方法]]></title>
      <url>%2F2015%2F03%2F31%2Fsingleton-process%2F</url>
      <content type="text"><![CDATA[方法一：共享静态数据。 此方法参见《Windows 核心编程》第 5 版 17.1.2 章节《在同一个可执行文件或 DLL 的多个实例间共享静态数据》。 实现原理： 创建一个自己命名的段，将其属性改为 READ|WRITE|SHARED，其中 SHARED 属性表示该段的内容为多个实例所共享（实际上关闭了写时复制机制），将变量放在该段内若值被改变，多个实例间都会受到改变的影响。 注意点： 最好使用 volatile 修饰变量。 对变量的增减推荐使用原子操作函数 InterlockedExchangedAdd。 g_lInstances 的值在第一个实例运行时总为 0，其它实例中取到的值以先于它运行的实例中改变后的值为准。 示例代码： 123456789101112131415161718192021222324#include &lt;Windows.h&gt;#pragma data_seg("Shared")volatile long g_lInstances = 0;#pragma data_seg()#pragma comment(linker, "/Section:Shared,RWS")int main(int argc, char *argv[])&#123; if (g_lInstances != 0) &#123; return -1; &#125; InterlockedExchangeAdd(&amp;g_lInstances, 1); // do something here // ... InterlockedExchangeAdd(&amp;g_lInstances, -1); return 0;&#125; 方法二：使用 Mutex。 理论上能用于进程间同步的内核对象比如事件和互斥量等都能用于实现此功能，此处使用互斥量 Mutex 举例。 实现原理： 使用操作系统范围内可见的命名内核对象，不同实例间检测同一个内核对象的状态来判断是否为当前唯一实例。 注意点： 内核对象要使用全局命名，比如此处使用 Global 开头。 示例代码： 1234567891011121314151617181920212223242526272829#include &lt;Windows.h&gt;int main(int argc, char *argv[])&#123; HANDLE hMutex = NULL; do &#123; hMutex = CreateMutex(NULL, FALSE, "Global\\73E21C80-1960-472F-BF0B-3EE7CC7AF17E"); DWORD dwError = GetLastError(); if (ERROR_ALREADY_EXISTS == dwError || ERROR_ACCESS_DENIED == dwError) &#123; break; &#125; // do something here // ... &#125; while (false); if (NULL != hMutex) &#123; CloseHandle(hMutex); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个 printf 引发的基础复习]]></title>
      <url>%2F2015%2F01%2F19%2Fprintf%2F</url>
      <content type="text"><![CDATA[先看一下引发我追究一下 printf 和栈桢等相关知识的一段简单的程序： 12345678#include &lt;stdio.h&gt;int main()&#123; printf("%d ", 8.0/5); printf("%.2f", 8/5); return 0;&#125; 初看时，想当然了一下觉得输出就是1 1.00，后来编译出来运行一下，屏幕上却赫然是-1717986918 1.60。 在脑中干想了良久，其时的疑惑主要有两点： 1.6 转换为整形怎么就变成了负数。 1 转换为浮点数怎么就变成了 1.60。 现在看来当时的理解中存在着一个很大的误区，就是觉得 printf 是将参数根据格式化字符串进行强制类型转换之后再进行输出的，即编译器会自动将程序变换成如下模样： 12345678#include &lt;stdio.h&gt;int main()&#123; printf("%d ", (int)(8.0/5)); printf("%.2f", (float)(8/5)); return 0;&#125; 但是第一段程序的输出已经打脸了，那么想想办法找找合理的解释。 分析面对这类问题，现象诡异程序简单，能想到的最有效的方法之一就是看汇编。 使用g++ -S编译出第一段程序的汇编如下： 123456789101112131415161718192021222324252627282930313233 .file &quot;demo.cpp&quot; .def ___main; .scl 2; .type 32; .endef .section .rdata,&quot;dr&quot;LC1: .ascii &quot;%d \0&quot;LC2: .ascii &quot;%.2f\0&quot; .text .globl _main .def _main; .scl 2; .type 32; .endef_main: pushl %ebp movl %esp, %ebp andl $-16, %esp subl $16, %esp call ___main fldl LC0 fstpl 4(%esp) movl $LC1, (%esp) call _printf movl $1, 4(%esp) movl $LC2, (%esp) call _printf movl $0, %eax leave ret .section .rdata,&quot;dr&quot; .align 8LC0: .long -1717986918 .long 1073322393 .ident &quot;GCC: (GNU) 4.9.1&quot; .def _printf; .scl 2; .type 32; .endef 第一个 printf 结果的解释一眼望去，有没有发现一个熟悉的数？没错，我们程序的第一个输出 -1717986918 赫然在目。由此产生的猜想： LC0 对应的两个。long 合起来是 double 类型的 8.0/5，而对其低位 4 字节进行截取后对应的整数为 -1717986918。 来把相关的数转换成二进制验证一下（IEEE 浮点数表示法相关知识见附：IEEE 754 浮点数表示法）： -1717986918 转换成十六进制为 -0x66666666，对应的二进制为： 11110 0110 0110 0110 0110 0110 0110 因为负数在内存中使用补码存储，故将如上二进制转换为补码才是它在内存中的样子： 11001 1001 1001 1001 1001 1001 1010 1073322393 转换成十六进制为 0x3ff99999，对应的二进制为： 10011 1111 1111 1001 1001 1001 1001 将这两个数合起来，1073322393 作为高位就是： 10011 1111 1111 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 转换成浮点数恰恰就是 1.6000000000000001，可以认为与 8.0/5 的结果相符。所以第一个 printf 输出结果的推论： 给 printf 传递的是参数的原始类型，而不是根据格式化字符串进行强制转换后的类型。 比如printf(&quot;%d &quot;, 8.0/5);就会传 double 类型的 8.0/5，而不是根据 %d 强制转换成整型后再传参。 printf 在根据格式化字符串组成输出的时候，会直接在对应参数的起始地址读取一个格式指定的类型出来。 比如printf(&quot;%d &quot;, 8.0/5);就会在 double 类型的 8.0/5 的位置读取一个整型数出来，而小端模式下是高位高地址，低位低地址，所以这里是将 double 的低位 4 字节按 int 类型读取。 12345+--------------+| double low | --&gt; 把低位 4 字节当作 int 读取+--------------+| double high |+--------------+ 第二次 printf 结果的解释在上面的汇编代码中对第二次 printf 的调用部分如下： 123movl $1, 4(%esp)movl $LC2, (%esp)call _printf 可以看到传参确实传的整数 1 进去的，但是输出就变成了 1.60，结合我们对第一个输出的推论，则是会在整型 1 的位置读取一个 double 类型的数，并将内存中的整型 1 作为 double 的低位部分。为什么这里偏偏这么巧会是 1.60 而不是其它的什么值呢？结合上一次调用 printf 时传的参是 8.0/5 的情况，猜想： 受上一次调用后栈上残留数据的影响。 即： 12345+--------------+| int | -+----&gt; 把这 8 字节当 double 读取+--------------+ ||residual data | -++--------------+ 于是将第一次调用的传参修改一下将残留数据变化一下，即： 12345678#include &lt;stdio.h&gt;int main()&#123; printf("%d ", 9.0/5); printf("%.2f", 8/5); return 0;&#125; 果然如预料第二个 printf 的输出变成了 1.80。这又一次印证了对第一个输出分析后的两个结论。来复习一下基础，引自《深入理解计算机系统》里的一段话： 假设过程 P（调用者）调用过程 Q（被调用者），则 Q 的参数放在 P 的栈帧中。 即 printf 的参数是放在 main 函数的栈帧中的，那么两次调用call _printf前的堆栈情况应该是这样的： 1234567891011121314151617+-------------+ +-------------+| | ... | |+-------------+ +-------------+| | | |+-------------+ +-------------+| format str1 | &lt;-- esp | format str2 | &lt;-- esp+-------------+ +-------------+| double low | | int |+-------------+ +-------------+| double high | | double high |+-------------+ main stack frame +-------------+| ... | | ... |+-------------+ +-------------+| | | |+-------------+ +-------------+| (%ebp) | &lt;-- ebp | (%ebp) | &lt;-- ebp+-------------+ +-------------+ 这里面补充的关键知识点： 被调用函数的参数存放在调用函数的栈帧中。 IEEE-754123+---+-----+----------+| S | Exp | Mantissa |+---+-----+----------+ S：符号位 Exp：指数偏差 Mantissa：尾数 单精度（32 位） S：1 位 Exp：8 位，二进制科学计数法中的指数加 127（2^(8-1)-1） Mantissa：23 位，二进制科学计数法中的小数部分 双精度（64 位） S：1 位 Exp：11 位，二进制科学计数法中的指数加 1023（2^(11-1)-1） Mantissa：52 位，二进制科学计数法中的小数部分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 gVim 的 Python 自动补全时遇到的问题]]></title>
      <url>%2F2014%2F12%2F21%2Fvim-python-autocomplete%2F</url>
      <content type="text"><![CDATA[问题描述环境：Win7 x64 从 gVim 7.4 的安装目录 /path/to/Vim/Vim74/autoload 下的 pythoncomplete.vim 看出，Vim 在这个版本已经默认内置了对 Python 的自动补全的支持。然而我在自己的笔记本上用得很好的配置，同样的、_vimrc 和插件平移到工作机上以后就出问题了，&lt;C-x&gt;&lt;C-o&gt;的时候 gVim 底部提示： 12Error: Required vim compiled with +pythonE117: Unknown function: pythoncomplete#Complete 解决过程 排查 Vim 版本编译时的 Python 支持 根据上面的错误提示，首先想到的是 gVim 编译时未加入 +python 选项。 vim --version gvim --version 由此看出，在 Vim.org 下载的 Windows 版 gVim 的 Vim 编译时倒确实未启用 Python 支持，但是 gVim 启用了。我明明使用的是 gVim，不是 Vim 呀！难道 gVim 其实只是一个调用 Vim 的壳？窃以为不太可能……上 Vim.org 找了半天，从描述上没看出来提供的几个 MS-Windows 安装包的 Python 支持的相关说明，下载了一个与之前下载的版本不同的版本安装了，结果还是与上面一样，笔记本上都可以做到，那应该不是 gVim 版本的问题。 验证 gVim 的 Python 支持 :python print &#39;hello&#39; 看到 gVim 下方的错误输出： 12E370: Could not load library python27.dllE263: Sorry, this command is disabled, the Python library could not be loaded. 提示无法加载 python27.dll。使用 everything 小工具在磁盘里找了一下，发现能找到 C:\Windows\system32\python27.dll，这个路径应该是直接在系统环境变量里的，为何会无法加载呢？除非……gVim.exe 是 32 位程序，在任务管理器里看： 那看样子我安装的 Python 是 64 位版本的。在命令行里执行 Python.exe 看了一下果然如此： 123Python 2.7.9 (default, Dec 10 2014, 12:28:03) [MSC v.1500 64 bit (AMD64)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt;&gt;&gt;&gt; 结论Vim 官网下载的 Windows 版本 gVim 的 GUI 程序编译时启用了 Python 支持，但是由于 gVim.exe 是 32 位程序，需要加载 32 位的 python27.dll。 所以： 如果在 Windows 下使用 gVim 写 Python 而且想要自动补全，那安装的 gVim 与 Python 的版本要对应，比如使用的官网下载的 32 位 gVim，就安装 32 位的 Python 吧！ 当然如果愿意折腾，使用 64 位 Python，然后自己编译一个 64 位的 gVim 应该也不是一个坏主意。 验证卸载掉 64 位的 Python，安装 32 位的，可以看到 C:\Windows\SysWOW64 文件夹下有了之前没有的 python27.dll 文件。再执行 Python 的自动补全，已经能看到了：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 核心编程中文第二版课后练习 3.8 答案]]></title>
      <url>%2F2012%2F04%2F08%2Flearn-python-practise%2F</url>
      <content type="text"><![CDATA[3-1 变量在第一次被赋值时自动声明。在赋值时解释器会根据语法和右侧的操作数来决定新对象的类型。 3-2 函数总是返回一个值，显式 return 的值或者 None。返回的值的类型也是动态确定。 3-3 因为变量名 xxx 对 Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。 3-4 可以，使用 “;” 3-5 可以，使用 “\” 或者括号 3-6 (a)x = 1, y = 2, z = 3 (b)z = 2, x = 3, y = 1 3-7 40XL, $aving$, 0x40L, thisIsn’tAVar, big-daddy, 2hot2touch, counter-1 不合法。不是以字母或者下划线开头，或者有非字母下划线数字的字符。print, if 是关键字。 3-10 用异常处理取代对 os.path.exists() 的调用： 1234567891011121314151617181920212223242526272829303132import osls = os.linesepwhile True: fname = raw_input('input a filename:')# if os.path.exists(fname):# print "Error: '%s' already exists" % fname# else:# break try: fobj = open(fname, 'r') except IOError, e: break; else: print "Error: '%s' already exists" % fname fobj.close()all = []print "\nEnter lines ('.' by itself to quit).\n"while True: entry = raw_input('&gt;') if entry == '.': break else: all.append(entry)fobj = open(fname, 'w')fobj.writelines(['%s%s' % (x, ls) for x in all])fobj.close()print 'Done!' 用 os.path.exists() 取代异常处理方法： 1234567891011121314151617181920import osfname = raw_input('Enter filename:')print#try:# fobj = open(fname, 'r')#except IOError, e:# print '*** file open error:', e#else:# for eachLine in fobj:# print eachLine,# fobj.close()if os.path.exists(fname): fobj = open(fname, 'r') for eachLine in fobj: print eachLine, fobj.close()else: print 'this file not exists' 3-11 1234567891011121314151617181920import osfname = raw_input('Enter filename:')print#try:# fobj = open(fname, 'r')#except IOError, e:# print '*** file open error:', e#else:# for eachLine in fobj:# print eachLine,# fobj.close()if os.path.exists(fname): fobj = open(fname, 'r') for eachLine in fobj: print eachLine.strip() fobj.close()else: print 'this file not exists' 3-12 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172"""to read or make a file"""import osdef makeTextFile(): '''make a file''' ls = os.linesep while True: fname = raw_input('input a filename:') # if os.path.exists(fname): # print "Error: '%s' already exists" % fname # else: # break try: fobj = open(fname, 'r') except IOError, e: break; else: print "Error: '%s' already exists" % fname fobj.close() all = [] print "\nEnter lines ('.' by itself to quit).\n" while True: entry = raw_input('&gt;') if entry == '.': break else: all.append(entry) fobj = open(fname, 'w') fobj.writelines(['%s%s' % (x, ls) for x in all]) fobj.close() print 'Done!'def readTextFile(): '''read a file''' fname = raw_input('Enter filename:') print #try: # fobj = open(fname, 'r') #except IOError, e: # print '*** file open error:', e #else: # for eachLine in fobj: # print eachLine, # fobj.close() if os.path.exists(fname): fobj = open(fname, 'r') for eachLine in fobj: print eachLine.strip() fobj.close() else: print 'this file not exists'def main(): '''main menu''' while True: print '1.Read a file' print '2.Make a file' print 'x.exit' myStr = raw_input('input your choice:') if myStr == '1': readTextFile() elif myStr == '2': makeTextFile() elif myStr == 'x': breakif __name__ == '__main__': main() 3-13 Windows 下 curses 模块貌似无法正常使用…… 迂回的实现思路是将文件内容按行读取到一个列表里， 然后让用户修改每一行， 最后让用户选择是否保存， 保存则重写文件， 不保存则退出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 核心编程中文第二版课后练习 2.21 答案]]></title>
      <url>%2F2012%2F04%2F05%2Flearn-python-practise%2F</url>
      <content type="text"><![CDATA[2-2 (a) 计算 1 + 2 * 4 (b) 无输出 (c) 一样。无输出语句。 (d) 单独执行无输出，在交互解释器里执行输出结果。 (e)print 1 + 2 * 4 2-4 (a) 12str = raw_input('input a str:')print str (b) 12str = raw_input('input a int:')print int(str) 2-5 (a) 1234i = 0while i &lt;= 10: print i, i += 1 (b) 12for eachNum in range(11): print eachNum, 2-6 1234567num = raw_input('input a num: ')if num &gt; 0: print '正数',elif num &lt; 0: print '负数',else: print '0', 2-7 123456789myStr = raw_input('input a str: ')i = 0while i &lt; len(myStr): print myStr[i], i += 1myStr = raw_input('input a str: ')for c in myStr: print c, 2-8 123456789101112aList = list()for i in range(5): num = raw_input('input a num : ') aList.append(int(num))i = 0myNum = 0while i &lt; len(aList): myNum += aList[i] i += 1print 'myNum is : %d' % (myNum) 2-9 123456aTuple = [ 1, 2, 3, 5, 6]myNum = 0for i in aTuple: myNum += iprint 'average value is : %f ' % (float(myNum) / len(aTuple)) 2-10 12345678b = bool(False)while b is False: num = int(raw_input('input a num among 1 to 100 : ')) if num &gt;= 1 and num &lt;= 100: print 'succeed!' break else: print 'input error!' 2-11 1234567891011121314151617181920212223242526def display_menu(): """展示菜单""" print '1. 取五个数的和' print '2. 取五个数的平均值' print 'x. 退出' sel = str(raw_input('输入您的选项：')) return seldef tuple_sum(aTuple): """求和""" num = 0 for i in aTuple: num += i return numaTuple = (1, 2, 3, 4, 6)while True : sel = display_menu() if sel == str('1'): print 'num is : %d ' % tuple_sum(aTuple) elif sel == str('2'): print 'average is : %f ' % (float(tuple_sum(aTuple))/len(aTuple)) elif sel == str('x'): break else: continue 2-15 (a) 1234567891011121314151617num1 = int(raw_input('input num1:'))num2 = int(raw_input('input num2:'))num3 = int(raw_input('input num3:'))if num1 &gt; num2: tmp = num2 num2 = num1 num1 = tmpif num2 &gt; num3: tmp = num3 num3 = num2 num2 = tmpif num1 &gt; num2: tmp = num2 num2 = num1 num1 = tmpprint 'min to max is %d, %d, %d' % (num1, num2, num3) (b) 1234567891011121314151617num1 = int(raw_input('input num1:'))num2 = int(raw_input('input num2:'))num3 = int(raw_input('input num3:'))if num1 &lt; num2: tmp = num2 num2 = num1 num1 = tmpif num2 &lt; num3: tmp = num3 num3 = num2 num2 = tmpif num1 &lt; num2: tmp = num2 num2 = num1 num1 = tmpprint 'min to max is %d, %d, %d' % (num1, num2, num3) 2-16 1234fobj = open('hello.txt', 'r')for eachLine in fobj: print eachLine,fobj.close()]]></content>
    </entry>

    
  
  
</search>
